//----------------------------------------------------------------------------//

Файловая система. Пути и каталоги:

каталог приложения(AppDir) - путь до исполняемого файла(приложения)
корневой каталог(RootDir) - корень файловой системы. все пути считаются вложенными в корневой каталог
пути поиска (SearchPath) - один и более путей образуют виртуальную файловую систему 
каталог данных приложения(DataDir) - основной каталог данных приложения
каталог данных движка(EngineDir) - каталог данных движка


MyGame
	Game.fs
	Benchmark.fs
	Bin
		Debug (x86)	// AppDir
			Game.exe 
			Benchmark.exe 
	Rx // SearchPath
		Shaders
			HLSL
	SharedData // SearchPath			
	Game // RootDir
		Game.fs
		Data // SearchPath
			Shaders
				HLSL
					Generated
					Cache.bin
				GLSL
					Cache.bin
			Textures
			Meshes
				Building
				Vegetation
				Creatures
				Vehicles
				Items
				Interior
				Exterior
				Weapons
			Levels
				Intro
					LevelInfo.cfg // 'Levels/Intro/LevelInfo.cfg'
			Scripts
		Resources0.pack // SearchPath
		Resources1.pack // SearchPath
		Resources2.pack // SearchPath
		Mod.pack //
		Logs
		Configs
			Input.cfg // 'Configs/Input.cfg'
			Video.cfg
		Saves
			QuickSave.sav // 'Saves/QuickSave.sav'
	Benchmark // RootDir
		Configs
			Preset0.cfg // 'Configs/Preset0.cfg'


gFileSystem->SetRootDir("../../Data/Demo"); // $(RootDir) = $(AppDir)../../Data/Demo/
gFileSystem->AddSearchPath("../Rx"); // = $(RootDir)../Rx/
gFileSystem->AddSearchPath("../SharedData"); // = $(Root)../SharedData/
gFileSystem->AddSearchPath("../Data"); // = $(RootDir)../Rx/
gFileSystem->AddSearchPath("Resources0.pack"); // = $(RootDir)Resources0.pack/
gFileSystem->AddSearchPath("Resources1.pack"); // = $(RootDir)Resources1.pack/
gFileSystem->AddSearchDir("Resources2.pack"); // = $(RootDir)Resources2.pack/
gFileSystem->AddSearchDir("Mod.pack", 100); // = $(RootDir)Mod.pack/

or..
gFileSystem->AutoConfigure(); // load from $(AppName).fs
		


//----------------------------------------------------------------------------//

Многопоточность в движке:
- ресурсы загружаются аснихронно
- многопоточный рендеринг (составление списка комманд рендеринга в нескольких потоках, исполнение в одном)
- пока составляются списки комманд рендеринга, главный поток рендеринга обновляет пул графических ресурсов (текстуры, геометрия и т.д.)
- большинство систем работают параллельно, с синхронизацией по запросу
- главное окно, устройства ввода и игровая логика (скрипты) работают в главном потоке
- каждая подсистема сцены (рендеринг, физика, звук, анимация) работает в отдельном потоке, синхронизация в конце кадра

//----------------------------------------------------------------------------//

Многопоточный рендеринг:
- один главный контекст и множество списков комманд рендеринга
- главный контекст непосредственно отправляет все комманды драйверу
- отложенный контекст позволяет создавать списки комманд для последующего выполнения
- работать с контекстом (главным или отложенным) можно только из одного потока (любого)
- ресурсы (текстуры, буфера, шейдера) можно создавать и модифицировать в любом потоке
- ресурс модифицируется с минимальной задержкой
- список комманд зависит от текущего состояния ресурсов (до выполнения списка нужно обновить необходимые ресурсы)

Разделение на потоки:
* главный поток
	- работает с главным контекстом
	- получает список видимых объектов и запускает составление списков комманд
	- отправляет списки на отрисовку
	- подгружает текстуры и данные в видеопамять (пока идет заполнение списков комманд)
* второстепенные потоки (рендеринг сцены)
	- каждый поток формирует проход сцены/материала
	- сортирует полученный в главном потоке список объектов


такой подход позволит распределить нагрузку на несколько ядер процессора

T0(single): get objects, get lights, upload textures/buffers, sort/draw solid objects, sort/draw lights, sort/draw transparent objects, posteffects, swap buffers


T0(main)        : get objects |	upload textures, upload buffers | wait | execute | swap buffers
T1(gbuffer)		: wait		  | sorting, rendering					   | sleep
T2(lighting)	: wait		  |	get lights, sorting, rendering		   | sleep
T3(transparency): wait		  |	sorting, rendeting, lighting ...	   | sleep
T4(posteffects)	: effect0, effect1, ... effectN 					   | sleep

//----------------------------------------------------------------------------//

***обычный игровой цикл: (один поток)

*получение событий окна
*обновление интерфейса
*добавление объектов на сцену
*вызов скриптов
	*перемещение объектов
	*модификация объектов
	*обработка триггеров
	*искусственный интеллект (поиск путей, смена анимации, спавн объектов)
*анимация
	*скелетная анимация
	*инверсная кинематика
	*вызов скриптов
*передача трансформаций в физический движок
*обновление физического движка
	*силовые поля
	*разрушаемые объекты
	*триггеры
*синхронизация объектов с физическими телами
*обновление мировых матриц
*обновление дерева ограничивающих объемов
*рендеринг сцены
	*получение объектов
	*сортировка
	*анимация материалов
	*рендеринг
	*постобработка
*рендеринг поверх сцены
*рендеринг интерфейса
*переключение буфера кадра

//----------------------------------------------------------------------------//

Q. Нужны ли узлу компоненты и скрипты?
	- удаление по таймеру
		ненужен. это встроенное свойство.
	- поведение узла (следование, вращение и т.д.)
		нужен. для автоматизации перемещения узла.
	- набор декалей
		ненужен. все узлы, на которые могут накладываться декали имеют DecalSet
	- кастомизируемое поведение (напр. контроллер персонажа или силовое поле)
		ненужен. усложняет взаимодействие объекта и узла. кастомная логика реализуется в самом объекте или в скрипте прикрепленному к объекту 
	- триггер (физический объект)
		ненужен. это встроенное свойство физического тела. логика реализована в объекте/скрипте

Q. Эффекты при столкновениях
	- звуки обрабатываются физическим материалом
	- наложение декалей? (следы пуль, шин и т.д.), где хранить информацию о типах декалей

	
Q. Обновление узлов
	узлы обновляются в зависимости от типа и выбранной политики	обновления.
	узел активируется по какому либо признаку и деактивируется самостоятельно, в зависимости от настроек и типа.

Q. Деактивация узлов
	при активации, узел добавляется в список обновляемых объектов. (и наоборот)
	при обновлении, узел сам проверяет необходимость деактивации.
	внешние объекты также могут управлять активацией узла
Q. Нужно ли иерархическое обновление?
	в общем случае ненужно.
	в частных случаях используется двухуровневое обновление (pre/post) или другие алгоритмы обновлений
Q. Обновление мировой матрицы
	если узел был перемещен, он помещается в список обновления и обрабатывается перед рендерингом
Q. Обновление пространственного индекса
	в зависимости от типа и состояния узла, он может регистрироваться в системе пространственного поиска (Octree/Dbvt)
	если узел был перемещен, он помещается в список обновления и обрабатывается перед рендерингом
Q. Узлы в центре камеры
Q. 
Q. Автоматическое создание/удаление физических объектов в радиусе от игрока
Q. Динамическая подгрузка узлов/объектов
Q. 
Q. Виды разрушаемых объектов
Q. 
Q. 2D сцена
Q. Комбинированная сцена
Q. 


	

